## Leading Question 
The leading question for our project is given a start bitcoin user and an end user we want to first see if a path between them is possible, and if so find a path based upon various constraints. These constraints may include the number of middle men between the two users, the cumulative trustworthiness the user would like to have when making the transaction, as well as identifying the most important members of the bitcoin network. We will be creating a graph network to track and test the aforementioned questions and will use various traversals such as BFS, DFS, and some algorithms such as A* search algorithm to track and find the shortest path.
## Dataset Acquisition
The dataset that we have chosen is from the Stanford Large Network Dataset Collection and it is the Bitcoin OTC trust weighted signed network dataset. The link is provided here: http://snap.stanford.edu/data/soc-sign-bitcoin-otc.html.

## Data Format
The input dataset that we are given contains four fields. The fields are the source or start node, the target or end node, the rating, which is how trustworth the connections between the two users are, and the time of the rating. In order to format the data the only thing that we will have to do is remove the TIME column as it is irrelevant to our leading question/ problem statement.
## Data Correction
For the data correction part of the task we will import the data into an excel spreadsheet or google spreadsheet and use their inbuilt functions to check for any missing data points. If the time is missing we will do nothing, however if important information such as the edge weight is missing we will have to remove that data row. 
## Data Storage
For the data storage aspect of the problem we will have two main tasks. The first is to create a class for the user/graph node storing the relevant information as member variables within the class. The second is to create a Bitcoin Network class which will contain a map as well as all the various methods that we would like to perform on the graph network. This map will be our primary storage of the network. The map will have a key of the node class mentioned earlier, and the value will contain a list of pairs representing the neighbors. This pair will have the trustworthiness of the current node to whichever neighbor it is connecting to as well as the node as the second value. The population of this map will require some sort of traversal whether it is a DFS or BFS and this will take O(n) time, where n is the number of nodes in the network. The space complexity will be O(V + E) as we are storing all the nodes (vertices) and their neighbors. This may be subject to refinement as we get further into the project. 
## Algorithm 
There are various algorithms that we will be employing throughout this project. To begin with, as mentioned earlier we will either employ DFS or BFS, maybe both in order to populate our map that is representing the map network. For our various functions, the common inputs will be the start node or start user, and the end user. This user is the user they would like to make the transaction to. If no path is available within the given constraints we will throw an error. There will be other constraints that we have planned, for instance a user may want a certain trustworthiness to make the transaction, or they may also just want the shortest path to the end user without taking into account trustworthiness. For the shortest path algorithm, we will use the A* search algorithm. We decided to use this over Djikstra’s algorithm because the A* search algorithm gives us the shortest path from a specified starting point to a specified goal. Djikstra’s on the other hand gives the shortest path from a specific start point to all possible targets. The worst case time complexity will be O(E), where E represents all the edges in the graph. The worst case space complexity will be O(V), where V represents the vertices. The other graph algorithm we plan to use is Edmond’s algorithm. This finds the spanning arborescence of minimum weight. It is the directed analog for the minimum spanning tree. The running time of this algorithm is O(EV). 
## Timeline
    Week 1 (Nov 6-12)
     - I think this first week should be targeted on getting very familiar with the data. This includes correcting the data, and doing overall research on the idea to become more acquainted with the idea of bitcoin trading. 
    Week 2 (Nov 13-19)
    - We should use this week to start coding. This includes setting up our classes and reading into the data set. This part is very integral to our project, since if we are able to efficiently set this up the rest of the project will be easier. 
    Week 3 (Nov 20-26)
    Week 4 (Nov 27-Dec 3)
    - These next two weeks should be focused completely on implementing the functions we created. This is where the meat of the work will be done. Obviously problems are anticipated, so debugging will probably consume most of the time. 
    Last Week
    - Hopefully we are able to be almost or completely done with the project at this point. This gives us time to improve/touch up on our work. I think that this timeline is very up to change. Depending on how the work is going changes will be made to our plan. We will be open to making changes if our initial plan isn't working. 
